/* File: search.c * -------------- * The leland search engine takes one argument, the filename of users,  * parses those home pages, and then goes into a loop to allow * the user to do interactive lookups until they quit. The number of * matches is printed, and the user has a chance to respond to * whether they would like to see the full list. If printed, the * full list contains the names, numbered and in alphabetical order. */#include <assert.h>#include <stdlib.h>     // for malloc()#include <string.h>     // for strcasecmp()#include <ctype.h>      // for tolower()#include <stdio.h>      // for printf()#include <limits.h>     // for PATH_MAX#include "scanner.h"#include "hashtable.h"#include "darray.h"#define DELIMITERS              " \t\n\r.,!\"(){};:/?\\*&^%$#@<>=[]~-`|+<>"#define MAX_WORD_LEN            64#define MIN_WORD_LEN            4#define DEFAULT_BUCKETS         2048#define DEFAULT_NUM_USERS       4struct WordEntry {    char        *word;      // unique word    DArray      users;      // list of users who use word};struct WordUser {    char        *name;      // name of user who uses word};static void     WordUserPrint(void *elem, void *clientData);static void     IndexUserPage(const char *username, HashTable wordTable);static void     ExtractWordsIntoTable(const char *username, Scanner s, HashTable wordTable);static void     AddWordEntry(const char *username, const char *word, HashTable wordTable);static struct   WordEntry *FindWordEntry(HashTable wordTable, const char *word);static int      FindWordUser(DArray users, const char *name);static void     AddWordUser(const char *newUser, DArray users);static int      WordEntryHash(const void *elem, int numBuckets);static int      WordEntryCompare(const void *entry1, const void *entry2);static void     WordEntrySort(void *elem, void *clientData);static void     WordEntryFree(void *elem);static int      WordUserCompare(const void *user1, const void *user2);static void     WordUserFree(void *elem);static int      StringHash(const char *s, int numBuckets);static bool     ContainsOnlyAscii(const char *s);static char     *CopyString(const char *s);static char     safetolower(char ch);int main(int argc, char *argv[]){        Scanner             userScanner;    char                buffer[MAX_WORD_LEN];    HashTable           wordTable;    Scanner             inputScanner;    struct WordEntry    *foundElem;    int                 usercounter;        printf("\nWelcome to the leland homepage frequency service!\n");    if (argc < 2) {        printf("\nOOPS!  This program takes one argument which is the file\n");        printf("of usernames whose home pages you wish to search. Please try again!\n\n");    } else {        userScanner = NewScannerFromFilename(argv[1], " \t\n\r", true);        if (userScanner == NULL) {            printf("\nCan't open user file %s.\n", argv[1]);        } else {            wordTable = TableNew(sizeof(struct WordEntry), DEFAULT_BUCKETS, WordEntryHash, WordEntryCompare, WordEntryFree);            printf("Hold on while I process the home pages (may take a while)..\n");            while (ReadNextToken(userScanner, buffer, MAX_WORD_LEN))                 IndexUserPage(buffer, wordTable);               FreeScanner(userScanner);            TableMap(wordTable, WordEntrySort, NULL);            printf("Done. Table contains %d unique words.\n", TableCount(wordTable));                        inputScanner = NewScannerFromFile(stdin, " \t\n\r", true);            while (true) {                printf("\nPlease enter a word to search for (\"quit\" to quit): ");                if (ReadNextToken(inputScanner, buffer, MAX_WORD_LEN) == false)                     break;                if (strcasecmp("quit", buffer) == 0)                     break;                if (strlen(buffer) < MIN_WORD_LEN) {                    printf("Sorry, words under length %d, such as \"the\", are not indexed.\n", MIN_WORD_LEN);                    continue;                }                foundElem = FindWordEntry(wordTable, buffer);                if (foundElem == NULL) {                    printf("No matches found for \"%s\".\n", buffer);                } else {                    printf("Found %d matches for \"%s\". See the list? (y/n): ", ArrayLength(foundElem->users), buffer);                    while (true) {                        if (ReadNextToken(inputScanner, buffer, MAX_WORD_LEN) == false)                            break;                        if (strcasecmp("y", buffer) == 0) {                            usercounter = 0;                            ArrayMap(foundElem->users, WordUserPrint, &usercounter);                            break;                        }                         if (strcasecmp("n", buffer) == 0)                             break;                        printf("Please enter y or n. Try again.\nSee the list? (y/n): ");                    }                }            }            FreeScanner(inputScanner);            TableFree(wordTable);        }    }    return 0;}/* WordUserPrint * ------------- * Function given to ArrayMap to print the list of a word's users. * Uses a user counter to keep track of what number user we are printing. */static void WordUserPrint(void *elem, void *clientData){    struct WordUser     *e = (struct WordUser *)elem;    int                 *userCounter = (int *)clientData;        // pre-increment user counter to start count from 1        printf("%7d) %s\n", ++(*userCounter), e->name);}/* IndexUserPage * ------------- * Given a username, this constructs the path to that user's home * page and attempts to open a Scanner for that filename; if the  * call returns null, the file didn't exist or couldn't be opened  * and we just return. Otherwise, we extract valid words into the  * word table and clean up.   */static void IndexUserPage(const char *username, HashTable wordTable){    Scanner     pageScanner;    char        filename[PATH_MAX];        // construct leland path to user's webpage        sprintf(filename, "/afs/ir/users/%c/%c/%s/WWW/index.html", username[0], username[1], username);    pageScanner = NewScannerFromFilename(filename, DELIMITERS, false);    if (pageScanner != NULL) {        ExtractWordsIntoTable(username, pageScanner, wordTable);        FreeScanner(pageScanner);    }}/* ExtractWordsIntoTable * --------------------- * This uses the Scanner to extract the words from the file, by looping * calling ReadNextToken until it returns false (which indicates end of * file).  If the word is over the minimum length, we add it to the table  * if not already present.  Since we know that we are parsing HTML files,  * we make a specific effort to exclude tags by checking if the token  * begins with '<', and if so, we quickly skip everything up to the  * closing '>'. This avoids entering HTML tag words into our table.  * We use the stack for the storage for the word (because the stack * is cheap and quick), but if we need to store the word permanently * in the table, we have to make a new heap copy, since the stack buffer  * will be overwritten each time we read a new token. This copy is made * when adding the word to the table (see function AddWordEntry). */static void ExtractWordsIntoTable(const char *username, Scanner s, HashTable wordTable){    char    word[MAX_WORD_LEN];    while (ReadNextToken(s, word, MAX_WORD_LEN)) {        if (word[0] == '<')     // if HTML opening tag            SkipUntil(s, ">");  // skip to end of tag        else if (strlen(word) >= MIN_WORD_LEN && ContainsOnlyAscii(word))            AddWordEntry(username, word, wordTable);    } }/* AddWordEntry * ------------ * Given the name of a user and the word they use, this function * updates the word table. */static void AddWordEntry(const char *username, const char *word, HashTable wordTable){    struct WordEntry    newElem;    struct WordEntry    *foundPtr;        foundPtr = FindWordEntry(wordTable, word);    if (foundPtr == NULL) {        newElem.word = CopyString(word);        newElem.users = ArrayNew(sizeof(struct WordUser), DEFAULT_NUM_USERS, WordUserFree);        AddWordUser(username, newElem.users);        TableEnter(wordTable, &newElem);    } else if (FindWordUser(foundPtr->users, username) == NOT_FOUND)        AddWordUser(username, foundPtr->users);}/* FindWordEntry * ------------- * Given a table of word entries and a key to look for, this function * returns a pointer to the matched word entry or NULL. */static struct WordEntry *FindWordEntry(HashTable wordTable, const char *word){    struct WordEntry    searchElem;        searchElem.word = (char *)word;    searchElem.users = NULL;    return (struct WordEntry *)TableLookup(wordTable, &searchElem);}/* FindWordUser * ------------ * Given a list of word users and a name to look for, this function  * returns the list position of the matched word user or NOT_FOUND. */static int FindWordUser(DArray users, const char *name){    struct WordUser     currentUser;        currentUser.name = (char *)name;    return ArraySearch(users, &currentUser, WordUserCompare, 0, false);}/* AddWordUser * ----------- * Given a list of word users and a name to add, this function * appends a new word user to the list. */static void AddWordUser(const char *newUser, DArray users){    struct WordUser     currentUser;        currentUser.name = CopyString(newUser);    ArrayAppend(users, &currentUser);}/* WordEntryHash * ------------- * Hash function passed to TableNew to hash each word entry  * element to its proper bucket. */static int WordEntryHash(const void *elem, int numBuckets){    struct WordEntry    *e = (struct WordEntry *)elem;        return StringHash(e->word, numBuckets);}/* WordEntryCompare * ---------------- * Comparison function passed to TableNew to determine the  * alphabetical ordering of word entries. It uses strcasecmp which is * identical to strcmp, except that it sorts case-insensitively. */static int WordEntryCompare(const void *entry1, const void *entry2){    struct WordEntry    *e1 = (struct WordEntry *)entry1,                         *e2 = (struct WordEntry *)entry2;        return strcasecmp(e1->word, e2->word);}/* WordEntrySort * ------------ * Sort function passed to TableMap to sort each word entry's  * list of word users. * */static void WordEntrySort(void *elem, void *clientData){    struct WordEntry    *e = (struct WordEntry *)elem;        ArraySort(e->users, WordUserCompare);}/* WordEntryFree * ------------- * Free function passed to TableNew to free the contents of * each WordEntry element. */static void WordEntryFree(void *elem){    struct WordEntry    *e = (struct WordEntry *)elem;        if (e != NULL) {        if (e->users != NULL)            ArrayFree(e->users);        if (e->word != NULL)            free(e->word);    }}/* WordUserCompare * --------------- * Comparison function passed to ArraySearch to determine the  * alphabetical ordering of word entries. It uses strcasecmp which is * identical to strcmp, except that it sorts case-insensitively. */static int WordUserCompare(const void *user1, const void *user2){    struct WordUser     *u1 = (struct WordUser *)user1,                         *u2 = (struct WordUser *)user2;        return strcasecmp(u1->name, u2->name);}/* WordUserFree * ------------ * Free function passed to TableNew to free the contents of  * each WordUser element. */static void WordUserFree(void *elem){    struct WordUser     *e = (struct WordUser *)elem;        if (e->name != NULL)        free(e->name);}#define MULTIPLIER      -1664117991/* StringHash * ---------- * This function adapted from Eric Roberts' _The Art and Science of C_ * It takes a string and uses it to derive a "hash code," which  * is an integer in the range [0..NumBuckets-1]. The hash code is computed * using a method called "linear congruence." A similar function using this * method is described on page 144 of Kernighan and Ritchie. The choice of * the value for the Multiplier can have a significant effort on the * performance of the algorithm, but not on its correctness. * This hash function has the additional feature of being case-insensitive, * hashing "ZELENSKI" and "Zelenski" to the same code. */static int StringHash(const char *s, int numBuckets){    int             i;    unsigned long   hashcode = 0;        for (i = 0; i < strlen(s); i++)        hashcode = hashcode * MULTIPLIER + safetolower(s[i]);    return (hashcode % numBuckets);}/* ContainsOnlyAscii * ----------------- * This checks all of the characters in a string to determine if they are * plain ASCII characters (as determined by the isascii ctype function) * and returns true if the string contains only non-weird characters. */static bool ContainsOnlyAscii(const char *s){   int  i;   for (i = 0; s[i] != '\0'; i++) {        if (!isascii(s[i]))            return false;   }   return true;}/* CopyString * ---------- * Straight-forward utility function to make a new heap copy of a string. */static char *CopyString(const char *s){    char    *copy = malloc(strlen(s) + 1);        assert(copy != NULL);    strcpy(copy, s);    return copy;}static char safetolower(char ch){    return (isascii(ch) ? tolower(ch) : ch);}